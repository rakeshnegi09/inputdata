ALTER TABLE wp_postmeta
    DROP PRIMARY KEY,
    DROP INDEX post_id,
    ADD PRIMARY KEY(post_id, meta_key, meta_id),  
    ADD INDEX(meta_id);  
	
	The current AUTO_INCREMENT column is a waste of space, and slows down queries because it is the PRIMARY KEY, thereby eschewing the "natural" "composite" PK of (post_id, meta_key).
InnoDB further boosts the performance of that PK due to "clustering". (I hope you are not still using MyISAM!)
If you are using MySQL 5.6 (Or MariaDB 10.0 or 10.1), change meta_key from VARCHAR(255), not VARCHAR(191). (We can discuss the reasons, and workarounds, in a separate question, if 191 is not sufficient.)
INDEX(meta_key) is optional, but needed if you want to "find posts that have a particular key".
Caveat: These changes will speed up many uses of postmeta, but not all. I don't think it will slow down any use cases. (Please provide such queries if you encounter them. It could be a caching issue, not ar real degradation.)


add_filter( 'posts_results', 'cache_meta_data', 9999, 2 );
function cache_meta_data( $posts, $object ) {
    $posts_to_cache = array();
    // this usually makes only sense when we have a bunch of posts
    if ( empty( $posts ) || is_wp_error( $posts ) || is_single() || is_page() || count( $posts ) < 3 )
        return $posts;
         
    foreach( $posts as $post ) {
        if ( isset( $post->ID ) && isset( $post->post_type ) ) {
            $posts_to_cache[$post->ID] = 1;
        }
    }
     
    if ( empty( $posts_to_cache ) )
        return $posts;
 
    update_meta_cache( 'post', array_keys( $posts_to_cache ) );
    unset( $posts_to_cache );
 
    return $posts;
}